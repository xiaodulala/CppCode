大型软件的组织
头文件的编写
#ifndef __PRINT_H__
#define __PRINT_H__
//库的引入
//宏定义
//数据类型的定义  -->结构体等
//函数的声明
//变量的声明  -->跨文件使用变量
#endif

头文件的系统路径查看方式?
因为头文件都是在预处理的步骤执行的,使用命令 gcc -E -v  可查看编译过程. 然后查看系统默认搜索的头文件路径
#include "..." search starts here:
#include <...> search starts here:
 /usr/lib/gcc/x86_64-linux-gnu/5/include
 /usr/local/include
 /usr/lib/gcc/x86_64-linux-gnu/5/include-fixed
 /usr/include/x86_64-linux-gnu
 /usr/include

将头文件移动到系统指定头文件搜索路径中. 即可用<>引入头文件




源代码编译的步骤(细分)

main.c-->预处理-->main.i-->编译(检查c语法错误)-->main.s-->汇编--->main.o---->链接-->a.out
	 gcc -E            gcc -S 			  gcc -c             gcc   




库的链接
	库的一般链接
静态链接
	时机 这种链接发生在编译 链接形成可执行文件阶段 
	制作
		1.将要添加到静态库中的文件编译成目标文件
			gcc -c *.c  除了主函数
		2.打包目标文件到静态库
			ar -r libprint.a *.o
			静态库文件命名 lib+库名+.a 
		3.使用静态库文件生成可执行文件
			gcc -c main.c -Ldump -lprint 
			-L :存放静态库文件的路径
			-l :静态库名称  不是静态库文件名
			-I :将路径添加到系统指定目录

	可执行文件不依赖静态库 因为在链接的时候已经全部拷贝到可执行文件了 --->
	其实和上面的一般链接差不多,只不过是把几个源文件编译成目标文件后打包成了静态库文件.生成可执行文件后.可执行文件里包含所有的符号或者函数 已经全部在执行文件里面了.
动态链接(自动链接)
	时机 发生在代码加载到内存执行的时候 也叫共享库
	制作
		1.将要加入动态库的源文件,编译成与位置无关的目标文件
			gcc -fPIC *.c
		2.将目标文件打包成动态库文件
			gcc -shared -o libprint.so *.o
			动态库命名规则:lib+库名+.so 
		3.使用动态库文件链接成可执行文件
			gcc main.c -Ldump -lprint
			注意:既有动态库 又有静态库并且库名相同的时候,默认链接链接动态库
			如果指定使用静态库链接 要加-static
			使用动态链接生成的可执行文件依赖动态库文件,当a.out加载到内存时候,需要进程中使用的函数.但是找不到这些函数.
			
			如何查看可执行文件依赖那些动态库
				ldd a.out
		
		动态库文件由加载器加载到内存中,所以我们要想办法让加载器找到库文件
			1.环境变量 LD_LIBRARY_PATH  通过这个环境变量 告诉加载器搜索的路径
			2.加载器默认的加载路径是 /usr/lib /usr/local/lib  将动态库放到下面
		不管是连接器还是加载器 他们默认的搜索路径都一样  所有使用库文件做链接生成可执行文件的时候,可以省略-L
程序动态链接(动态链接)
	时机
		系统并不加载库函数,在程序需要的时候,通过程序向系统提出加载函数库的申请.系统再加载这个库文件
		系统提供了一组向系统提出加载函数库申请的函数 这些函数放在dl库中. 这些函数是程序动态链接加载库的编程接口
		
	dl函数
		首先必须包含头文件 dlfcn.h  编译的时候必须和动态库dl库链接  -ldl   exp:gcc -c xxx.c -ldl
		
		void *dlfopen(const char *filename,int flags)
		作用:打开一个指定的库
		参数:
			filename 字符串类型 库文件的名称
			flags  加载的方式  RTLD_LAZY 懒加载  RTLD_NOW 及时加载
		返回   NULL-->失败   成功返回动态库的地址
		
		int dclose(void *handle);
		作用:关闭动态库.如果动态库的引用计数减为0,则将这个动态库从内存中移除.(卸载)
		参数:
			handle  打开的动态库的地址
		返回   0是成功  非0是失败 用dlerror获得错误信息
		
		char *dlerror()
		作用:获取dl库函数中的报出的错误
		参数:void
		返回 NULL 没有错误. 有错误返回错误信息字符串的首地址
		
		void *dlsym(void *handle,const char *symbol)
		作用:在已经打开的动态库中找符号(也就是函数)
		参数:
			handle 打开的库
			sybol  符号 函数名称
		返回:  符号的地址  函数的地址

程序中的错误处理

		系统中直接维护着全局变量errno 当库函数或者系统调用出现错误的时候,为errno赋值.这个值叫错误号或者错误码.

		程序员可以获取到这个错误码.在使用相关的错误处理函数获取获取错误的描述信息 根据错误码	

		#include <errno.h>

		如何获得错误的描述信息
		perror()3;
		#include <stdio.h>
		void perror(const char *s)
		功能:输出一条系统的错误信息  
		参数
		  s:用户指定字符串  会当做提示语现在是屏幕上 后面是  s+:+错误信息+\n
		返回值
		  void

		strerror()3

		#include <string.h>

		char *strerror(int errnum)
		功能:获取描述信息
		参数:errnum 指定错误码
		返回值: 返回描述信息字符串的首地址.如果错误码没找到,返回 Unkonw error nnn


		补充
		流式文件
		标准输入  FILE *stdin 键盘
		标准输出  FILE *stdout 显示器
		标准错误输出 FILE *stderr  显示器


		举例说明 打开一个文件 出现错误 file_err.c

GDB调试工具的使用
	makefile 中文手册
	gdb 调试工具
	1.在生成可执行文件的时候,为可执行文件添加调试信息.
	如何为可执行文件添加调试信息呢?  在编译链接的时候加上 -g 或-ggdb  这个时候会增加调试信息
	2.使用gdb调试工具调试可执行文件  (必须有调试信息的文件)
	gdb 可执行文件的名称
	l 列出程序的源码
	b 行号或者函数的名字  设置断点
	r 执行程序 显示准备执行的语句
	n 下一条语句
	p a(p b) p后面跟变量,输出变量当前的值
	n 输出上一条结果和下一条准备执行的语句
	s step 下一步.切到函数里面.一直按s下一步
	q 退出调试.



大端和小端
高字节 低字节
00	01
低地址 高地址

高字节放在低地址 大端
高字节放在高地址 小端

网络采用大端
一般情况 主机采用小端

如何判断自己的主机字节序

shor var_s  = 0x0001;
char *p_var = &var_s;
*p = 0 高字节放到了低地址  大端
*p = 1 低字节放到了低地址  小端

一般用联合
union{
	short i;
	char c;
}



内存管理

虚拟地址
物理地址
操作系统负责物理地址到虚拟地址的映射
cpu直接访问虚拟地址 如果有物理地址对应这个虚拟地址 那么就可以访问 否则 segment fault
一个物理地址在不同的时间可以映射到多个虚拟地址
页表
映射的时候 是一块一块的内存映射  一块大小为4k。一块称为一页 内存页。物理地址中称为页框	

虚拟内存 物理内存(内存条 显卡  网卡)

虚拟地址 物理地址
虚拟地址和虚拟内存没有关系。

寄存器 cache memory disk net

/proc/pid/maps
静态局部变量空间分配在数据段  生命周期是进程  作用据是函数
全局变量的空间分配在数据段	生命周期是进程 作用域是从声明开始的整个文件
函数的名字前面加static 函数是内部函数 只能在源文件中使用。别的文件不可调用
const int c_a = 5 放在函数中的时候 不能叫常量  通过c_a访问空间的时候只读  空间分配在栈里
		  在函数外的时候 叫常量 空间分配在代码段

malloc分配的内存是在堆区里。 声明一个指针变量*p指向他。 然后free(p)的时候，只是将p和堆区的内存接触关联，
堆区的内存快并不会删除。 所以free后要将指针置空


物理地址到进程的虚拟地址 -->内存的映射
	以下函数映射到的虚拟地址空间在 堆和栈的中间 动态库也是用这个函数映射的
       #include <sys/mman.h>
	man 2
        void *mmap(void *addr, size_t length, int prot, int flags,int fd, off_t offset);
	功能：映射文件或设备到虚拟地址空间(内存)
	参数：
		addr 指定了映射区域的起始地址(进程中的虚拟地址)。如果为NULL 由系统内核选择映射区的地址
		length 指定了映射区域的长度
		prot 物理内存映射到虚拟内存时候的保护状态 
			以下参数 要不选择最后一个，要不选择前三个中的多个 按位或	 
			        PROT_EXEC  Pages may be executed.
       				PROT_READ  Pages may be read.
       				PROT_WRITE Pages may be writen.
       				PROT_NONE  Pages may not be accessed.
		flags 可能有多个进程映射的内存地址一样，通过下面选项决定
			MAP_SHARED   对内存区域的改动  显示到其他进程 并且修改底层文件。	
			MAP_PRIVATE  对内存区域的改动，不显示到其他进程，也不修改底层文件
			以下选项可以和上面选项作或操作
			MAP_ANONYMOUS 不支持任何文件映射(不拿文件) 选这个值 fd指定为-1 offset被忽略
		fd  -1 
		offset 0 
	返回值：	错误返回MAP_FAILED 成功返回映射区域的首地址
        
	int munmap(void *addr, size_t length);
	功能 解除映射
	参数
		addr mmap的返回值 肯定是页的整数倍
		length 指定了映射区域的长度 映射多少 解除多少。页的整数倍由系统完成
	返回值 成功 0  失败-1

	例子：使用mmap将物理地址映射到进程的虚拟地址，然后对内存进行操作  

	malloc实现的原理 是通过mmap实现的 加入缓冲机制 第一次调用malloc分配33*4096 用完再调用mmap



文件的操作
	open close read write lseek fcntl

	   #include <sys/types.h>
       #include <sys/stat.h>
       #include <fcntl.h>

        int open(const char *pathname, int flags);
        int open(const char *pathname, int flags,...);
		功能 打开并且有可能创建一个文件
		参数
			pathname 指定要打开文件的路径名
			flags	 
					O_RDONLY  只读, O_WRONLY 只写,  O_RDWR 可读可写. 三选一
					可以和以下标记按位或
					O_CREAT, 文件不存在就创建 在可变参数中给权限	
					O_EXCL, 如果和O_CREAT一起指定，文件存在的时候报错 文件不存在 创建文件
       				O_APPEND 以追加的模式打开文件 读写位置在文件的末尾
					O_TRUNC 如果创建一个文件 该文件存在并且是一个普通文件 将文件内容清空
			...:可变参数 参数的类型根据前面的参数决定  mode & ~umask
		返回值 成功 当前进程中最小的 未使用的文件描述符  错误-1

		补充：进程的本质就是记录程序在执行过程中对资源的使用情况 进程控制块PCB 来管理。
			 进程打开文件就是资源的使用 所以PCB中会有记录
			 文件描述符就是pcb里面那个数组的索引。
			 目前 可执行的进程都是在bash下启动的 所以 0 1 2 有特殊意义
				STDIN_FILENO  0  键盘
				STDOUT_FILENO 1	 显示器
				STDERR_FILENO 2  显示器
	
		#include <unistd.h>

       	int close(int fd);
		功能 指定关闭的文件描述符
		参数
		返回值 成功0 错误-1

		以读写方式打开一个文件 文件不存在创建 权限指定为0644 文件存在则清空内容


		#include <unistd.h>

       	ssize_t read(int fd, void *buf, size_t count);
		功能 从fd指定的文件中读取数据
		参数  fd 指定文件   buf 指定存储数据的缓冲区  cout 向系统申请的读取的最大字节数
		返回值 成功返回读取到的字节数 0代表到达文件末尾 -1是失败


        #include <unistd.h>

        ssize_t write(int fd, const void *buf, size_t count);
		功能 向文件中写入数据
		参数 fd 指定文件 buf指定了存放内容的地址 cout 指定要写入文件的最大字节数
		返回值 成功返回写入成功的字节数 失败 -1


		#include <sys/types.h>
        #include <unistd.h>

        off_t lseek(int fd, off_t offset, int whence);
		功能 重新定位文件的读写位置
		参数 fd 指定了相关的文件 offset 要定位的位置 和whence相关
			whence取值如下：
				SEEK_SET 相当于文件开头
				SEEK_CUR 文件当前位置
				SEEK_END 文件末尾
		返回值  成功返回当前定位的位置 失败返回-1

		补充 od 查看文件内容的内存位置


文件描述符的复制
流式文件	流入进程 从进程流出
文件重定向就是改变文件的流向
文件描述符复制
dup(2) dup2(2)
        #include <unistd.h>

        int dup(int oldfd);
	功能 赋值一个文件描述符
	参数 oldfd 指定了源描述符 新的文件描述符是进程中未使用的 最小的那个值
	返回值 失败-1 成功新的文件描述符

	
        int dup2(int oldfd, int newfd);
	功能 赋值一个文件描述符
	参数 oldfd 指定了原描述符 
		newfd 指定了新的描述符 如果指定的文件描述符正在使用 首先关闭新的文件描述符 再拷贝
	返回值 失败-1 成功返回新的文件描述符

	使用文件描述符的赋值 实现文件的输出重定向 

	#include <stdio.h>
	#include <sys/types.h>
	#include <sys/stat.h>
	#include <fcntl.h>
	#include <unistd.h>
	#include <string.h>
	/*
	 * 使用复制文件描述符完成输出重定向
	 * */
	int main (int argc,char *argv[])
	{
	    int stream_in_fd,std_out_fd;
	    int flags=O_WRONLY|O_CREAT;
	    char *buf="this is  a test\n";
	    mode_t mode=0644;
	    stream_in_fd = open(argv[1],flags,mode);
	    if(stream_in_fd == -1){
		perror("open file error");
		return -1;
	    }
	    
	    //复制标准输出文件描述符并保存
	    std_out_fd = dup(STDOUT_FILENO);
	    //将打开的重定向文件描述符复制到 标准输出文件描述符的位置
	    dup2(stream_in_fd,STDOUT_FILENO);
	    //这个时候再往标注输出写东西，会写到新的复制过去的文件描述符描述的文件
	    write(STDOUT_FILENO,buf,strlen(buf));
	    //写完了 关闭重定向输出文件
	    close(stream_in_fd);
	    //将标准输出的文件描述符复制回 标准输出的位置
	    dup2(std_out_fd,STDOUT_FILENO);
	    //输出一次
	    write(STDOUT_FILENO,buf,strlen(buf));
	    close(std_out_fd);
	    return 0;
	}

获取文件的元数据
	stat(2)
	值-结果参数  在函数调用的时候 给函数传递一个地址 然后函数将地址里的空间填写数据  函数调用完毕 主调函数使用地址空间里的数据
        #include <sys/types.h>
       	#include <sys/stat.h>
       	#include <unistd.h>

       	int stat(const char *pathname, struct stat *buf);

	struct stat {
               dev_t     st_dev;         /* ID of device containing file */
               ino_t     st_ino;         /* inode number */
               mode_t    st_mode;        /* protection */
               nlink_t   st_nlink;       /* number of hard links */
               uid_t     st_uid;         /* user ID of owner */
               gid_t     st_gid;         /* group ID of owner */
               dev_t     st_rdev;        /* device ID (if special file) */
               off_t     st_size;        /* total size, in bytes */
               blksize_t st_blksize;     /* blocksize for filesystem I/O */
               blkcnt_t  st_blocks;      /* number of 512B blocks allocated */

               /* Since Linux 2.6, the kernel supports nanosecond
                  precision for the following timestamp fields.
                  For the details before Linux 2.6, see NOTES. */

               struct timespec st_atim;  /* time of last access */
               struct timespec st_mtim;  /* time of last modification */
               struct timespec st_ctim;  /* time of last status change */

           #define st_atime st_atim.tv_sec      /* Backward compatibility */
           #define st_mtime st_mtim.tv_sec
           #define st_ctime st_ctim.tv_sec
           };

文件夹的操作
	opendir(2) closedir(3) readdir(3)
	
	 #include <sys/types.h>
       	#include <dirent.h>

       	DIR *opendir(const char *name);
	功能  打开一个文件夹 将读取位置定位在文件夹流的第一条记录上
	参数 文件夹地址
	返回值
	
	#include <dirent.h>

        struct dirent *readdir(DIR *dirp);
	
	struct dirent {
               ino_t          d_ino;       /* inode number */ inode号
               off_t          d_off;       /* not an offset; see NOTES */
               unsigned short d_reclen;    /* length of this record */
               unsigned char  d_type;      /* type of file; not supported
                                              by all filesystem types */
               char           d_name[256]; /* filename */
           };
	


文件锁的使用
	文件锁的分类    读锁 共享锁  写锁  互斥锁	
	实现上的分类 建议锁  强制锁
	建议锁
	如何在进程中使用建议锁
	fcntl(2)
	
	#include <unistd.h>
       	#include <fcntl.h>

      	int fcntl(int fd, int cmd, ... /* arg */ );
	功能 操控文件描述符
	参数 
		fd 指定了已经打开的文件描述符 要对这个文件描述符操控
		cmd  指定了堆该文件描述符操控的命令 
			F_SETLK	 设置锁 如果设置锁的时候，有互斥锁存在 立即返回-1并将errno设置为 					  EACCES OR EAGAIN 非阻塞
			F_SETLKW  和上面类似 但是有互斥锁存在的时候 等待互斥锁释放 阻塞
			F_GETLK   测试是否可以加锁。如果可以加锁 结构体成员l_type返回 F_UNLCK;
					如果有别的进程的锁互斥锁存在 结构体中返回这个锁的详细信息
			F_GETFL 拿到文件描述符的状态
		... 可变参数 依赖cmd

		  struct flock {
		       ...
		       short l_type;  锁的类型  /* Type of lock: F_RDLCK,
		                              F_WRLCK, F_UNLCK */
		       short l_whence;  锁的起始位置/* How to interpret l_start:
		                           SEEK_SET, SEEK_CUR, SEEK_END */
		       off_t l_start;   锁起始偏移位置/* Starting offset for lock */
		       off_t l_len;     锁多长/* Number of bytes to lock */
		       pid_t l_pid;     /* PID of process blocking our lock
		                         (set by F_GETLK and F_OFD_GETLK) */
		       ...
		   	};

	返回值
		 成功0 错误-1
	关闭文件描述符 文件描述符上的记录锁会全部被移除  同一个进程中加多个记录锁 会覆盖	
	举例  进程pa为文件加读锁 进程pb对文件也加读锁
	
	pa.c
			/*
		 * 打开一个文件 给文件加一把读锁 
		 * 另外一个进程pb 加读锁 ok 读锁是共享锁
		 * pb加写锁 不可以 写锁是互斥锁 非阻塞的情况
		 * pb加写锁  不可以 写锁是互斥锁 阻塞等待pa进程读锁接触 此进程加写锁成功
		 * */
		#include <stdio.h>
		#include <p_file.h>
		#include <fcntl.h>

		int main (int argc, char *argv[])
		{
		    int fd;
		    struct flock lock_info;
		    fd = open(argv[1],O_RDONLY);
		    if(fd == -1){
			perror("open error");
			return -1;
		    }

		    //初始化锁
		    lock_info.l_type=F_RDLCK;//家读锁
		    lock_info.l_whence=SEEK_SET;//从文件头开始加
		    lock_info.l_start=0;
		    lock_info.l_len=6;//给6个字节上锁
		    //给文件加读锁
		    int ft = fcntl(fd,F_SETLK,&lock_info); //记得要传锁的地址
		    if(ft==-1){
			perror("加锁失败");
			return -1;
		    }
		    printf("加锁成功...\n");
		    getchar();//文件关闭会删除所有此进程给文件加的记录锁 不让进程死掉
		    close(fd);
		}

	pb.c
		#include <stdio.h>
		#include <p_file.h>
		#include <fcntl.h>

		int main (int argc, char *argv[])
		{
		    int fd;
		    struct flock lock_info;
		    fd = open(argv[1],O_WRONLY);
		    if(fd == -1){
			perror("open error");
			return -1;
		    }

		    //初始化锁
		    lock_info.l_type=F_WRLCK;//家读锁
		    lock_info.l_whence=SEEK_SET;//从文件头开始加
		    lock_info.l_start=0;
		    lock_info.l_len=6;//给6个字节上锁
		    //给文件加读锁
		   // int ft = fcntl(fd,F_SETLK,&lock_info); //记得要传锁的地址 F_SETLK为非阻塞 加锁不成功 直接返回失败
		   int ft=fcntl(fd,F_SETLKW,&lock_info);
		    if(ft==-1){
			perror("加锁失败");
			return -1;
		    }
		    printf("加锁成功...\n");

		    close(fd);
		}


系统调用和库函数之间的关系  文件操作函数
fopen 调用的时候 首先分配一快内存 FILE *fp变量中的相关成员指向这个缓冲区相应的  再调用open打开文件 返回文件描述符 存放在fp的_fileno成员中

fgetc(3) 功能是从文件流中获取一个字符 fgetc从fp相应的成员中找到缓冲区的地址 从这个地址读取一个字符 如果缓冲区有数据 就直接读取立即返回 如果没有数据 调用read系统调用从系统中获取数据到缓冲区 然后fgetc再从缓冲区获取数据返回

fputc(3) 将字符方入写缓冲区中 如果缓冲区有充足的空间放入就返回 如果写缓冲区空间不足 调用write将写缓冲区的数据写入文件并清空写缓冲区文件 再讲字符放入缓冲区返回

fclose 将缓冲区的数据清空到文件 调用close关闭文件描述符 释放缓冲区


使用库函数操作的是缓冲文件  而使用系统调用操作的是非缓冲文件


文件操作的杂项
access() 
mkdir(2) 
rmdir(2)
umask(2)
unlink(2)
link(2)



关于进程

进程的创建
	在当前进程创建新的子进程 
	fork(2)
	#include <unistd.h>

       	pid_t fork(void);
	功能  创建一个子进程
	参数
	返回值  失败 再父进程返回-1 子进程没有创建 
		成功 在父进程中返回进程的pid 在子进程中返回0
	
	进程创建 子进程和父进程共用一个pcb 当子进程要改变父进程的资源时候，再复制子进程自己的pcb 写时复制

	

进程的退出
	
	exit(3)的调用会使当前进程终止
	#include <stdlib.h>
	void exit(int status);
	功能 让进程正常终止
	参数 指定退出状态码 status  status &0377传递给父进程
	返回值  不返回
	

	在进程退出的时候 可以调用遗言函数  需要向进程注册遗言函数 在进程退出的过程中 调用遗言函数
	atexit(3)
	
	#include <stdlib.h>

        int atexit(void (*function)(void));
	功能 向当前进程注册一个函数 在进程终止的时候调用
	参数 funciton : 指针类型的变量 存方一个地址 这个地址指向函数
	返回值 成功返回0 错误非0
	注意 	遗言函数的注册顺序和调用顺序相反  
		同一个函数可以被注册多次，每注册一次 就被调用一次
		子进程继承父进程的遗言函数

	on_exit(3)
	#include <stdlib.h>

        int on_exit(void (*function)(int , void *), void *arg);
	功能：向进程注册一个遗言函数
	参数： function 要注册的遗言函数的入口地址 arg 前面参数的第二个参数  第一个参数是exit的返回状态码
	返回值 成功返回0 失败返回非0
	
	_exit(2)
	#include <unistd.h>

        void _exit(int status);
	功能 终止当前进程 进程打开的所有文件描述符都关闭 进程的子进程 这些子进程过继给1号进程
	参数 status 指定了进程的退出状态码
	返回值 没有返回值


进程资源的回收
	进程终止的时候 需要释放进程的资源。内核管理进程是通过pcb来管理的。进程终止的时候 内核需要回收进程的pcb
	系统如何回收子进程的资源  wait和waitpid

	#include <sys/types.h>
        #include <sys/wait.h>

        pid_t wait(int *status); 等待子进程终止 进程不终止 一直等待 阻塞的 
	功能 等待进程状态的改变 状态的改变指的是 进程的终止 进程被信号停止  进程被信号恢复。
		如果父进程提供了wait 子进程终止的时候就释放资源  如果父进程没有提供wait 子进程终止后保留僵尸状态 这种进程叫做僵尸进程	
	参数 status  保存了子进程的退出状态码  低有效8位
	返回值 错误返回-1 成功返回 终止的子进程的pid被返回	
		 WIFEXITED(status) 如果子进程正常终止 返回真
		WEXITSTATUS(status) 正常终止的时候才使用 获取子进程的退出状态
		WIFSIGNALED(status) 被信号终止的时候返回真
		WTERMSIG(status) 获取终止子进程的信号编号


        pid_t waitpid(pid_t pid, int *status, int options);
	功能
	参数
		pid
			-1 等待任意子进程的终止
			>0 要等待的子进程的pid
			0 等待和父进程同组的任意子进程
			<-1 指定要等地的子进程的组id等于这个pid的绝对值
		options
			WNOHANG 如果没有子进程退出 立即返回  非阻塞
			0 等待子进程的结束 阻塞
	返回值

		成功返回终止的子进程的pid 如果指定了wnhang选项 没有子进程的退出 返回0 错误-1
		

更换进程的印象
	就是跟换进程中pcb资源的指向的代码段和数据段等 让其不在执行之前的代码。

	系统提供了 execve(2) 和exec(3) 家族函数来实现进程映像的更新
	
	#include <unistd.h>

        int execve(const char *filename, char *const argv[],char *const envp[]);
	功能 执行一个程序
	参数
		filename 指定了要执行的可执行文件的名字 脚本或者二进制文件
		argv 字符串列表 传递给新程序的字符串列表
		envp  字符串列表 环境变量
	返回值
		成功不返回 错误 error被设置			
	


	       #include <unistd.h>

       extern char **environ;

       int execl(const char *path, const char *arg, .../* (char  *) NULL */);
       int execlp(const char *file, const char *arg, ... /* (char  *) NULL */);
       int execle(const char *path, const char *arg, ... /*, (char *) NULL, char * const envp[] */);
       int execv(const char *path, char *const argv[]);
       int execvp(const char *file, char *const argv[]);
       int execvpe(const char *file, char *const argv[],
                       char *const envp[]);

	l list 将数组按照字符串一个个传 最后一个是NULL
	v Vector agrv[]数组直接传进区
	p  path环境变量 file可执行文件在环境变量中找
	e  环境变量 一般的情况下 子进程继承父进程的环境变量 如果需要给新的可执行程序传递新的可执行程序传递环境变量 就要用带e的 envp
	

在bash上启动一个进程的时候 发生了社么？
a.out-->fork--->exec(a.out)  
和bash一样 都是各自独立的可执行程序 这样的命令是外部命令
不是独立的可执行程序 是bash程序的一部分。这样的命令称为内部命令。
	



环境变量  2.5


system(3)
       #include <stdlib.h>

       int system(const char *command);
	

进程间通信---管道
	管道分为有名管道和无名管道两种
	无名管道 创建无名管道 使用pipe
		#include <unistd.h>

       		int pipe(int pipefd[2]);
		功能 创建管道。单向(双向的就再创建一个管道)  管道用于父子进程或者兄弟进程之间的通信
		参数 pipefd[2] 两个文件描述符分别指向了管道的两端 pipefd[0] 读端 pipefd[1] 写端
		返回值 成功0 错误-1
	有名管道
	可以用于任何进程间的通信 可以有亲缘关系 也可以没有亲缘关系 有名管道其实只是一个文件 这个文件是进程件通讯的桥梁 这个文件中不保存任何内容
	管道文件只是一个桥梁 对面不读 就写不进去  对面不写 就读不出来  都是阻塞的

	如何创建有名管道文件
	mkfifo(3)
	
	#include <sys/types.h>
        #include <sys/stat.h>

        int mkfifo(const char *pathname, mode_t mode);
	功能 创建一个有名管道文件 
	参数
		pathname 指定了管道文件的名字 
		mode 指定了管道文件的权限  mode&～umaks
	返回值  成功0 错误-1

	


文件输入重定向 2.5下午

关于信号
	信号就是软中断 软中断就是软件模拟中断机制。 信号也是进程间通信的一种 信号处理程序和进程是异步的
	查看linux系统下的信号有多少 kill -l
	2)SIGINT CTRL+C
	9)SIGKILL 杀死信号
	一共64个信号 没有32 33  62个信号

	信号的产生 信号递达给进程 -----(信号从产生到捕获这段时间 信号处于未决状态 叫未决信号)----->进程捕获信号	
	进程可以对信号屏蔽 相当于阻塞信号。


向进程注册信号处理函数 
	一般的情况下 进程从父进程继承信号处理函数。每个进程都有自己对信号的默认处理。默认处理动作就是终止当前进程
	进程的信号处理函数有三种  
		SIG_DFL  默认处理
		SIG_IGN  信号忽略
		用户自定义的信号处理函数
	 
	如何改变进程的信号处理函数
	signal(2)
	#include <signal.h>

        typedef void (*sighandler_t)(int);//定义了一个新的类型  这个类型是函数的访问方式

        sighandler_t signal(int signum, sighandler_t handler);
	功能：为指定的信号设置信号处理程序
	参数：
		signum:指定了信号的编号
		handler:指定了一个信号处理函数 这个函数是返回值空 形成一个int类型的
			可以是上面的三种
	返回值：错误返回SIG_ERR  成功返回旧的值
		
	#include <stdio.h>
	#include <signal.h>


	void doit(int n){
	    printf("recv...%d\n",n);
	    return ;
	}

	int main ()
	{
	    signal(2,SIG_IGN);
	    signal(3,doit);
	    while(1);
	    return 0;
	}

信号的产生
	硬件产生信号 ctrl+c 2     ctrl+\ 3
	使用命令发送信号 kill -信号编号  pid
	使用系统调用或者库函数产生信号  kill(2) alarm(2)  raise(3)
	#include <sys/types.h>
        #include <signal.h>

        int kill(pid_t pid, int sig);
	功能 给进程发送信号
	参数  pid 指定进程的pid  sig 指定信号的编号
	返回值 成功返回0 错误 -1 errno被设置
	
	编写代码实现kill命令功能
	

  	#include <signal.h>

        int raise(int sig);
	功能 发送一个信号给调用者 就是给进程自己发信号
	参数
		sig 指定信号
	返回值	成功0 错误非0


	#include <unistd.h>

        unsigned int alarm(unsigned int seconds);
	功能 产生一个SIGALRM信号 将该信号在seconds秒内 递达给当前进程
	参数
		senonds 指定了时间
		如果seconds指定为0 取消闹钟。原来设置的全被取消
		
	返回值 返回上次闹钟未执行的时间
	举个例子
			
信号阻塞和未决信号
	sigset_t 信号集类型  这种类型是系统封装的 系统负责提供关于这个类型的操作  起始是数据结构
	
       #include <signal.h>

       int sigemptyset(sigset_t *set);
	功能 初始化信号的集合为空 信号机中不包含任何信号
	参数 set 指定要初始化的信号机
	返回值
       int sigfillset(sigset_t *set);
	功能 初始化信号集为满 信号集合中包含所有信号
	参数 指定要初始化的信号集
	返回值
       int sigaddset(sigset_t *set, int signum);
	功能  向信号集添加信号
	参数 set 指定信号集  signum 指定要添加的信号
	返回值
       int sigdelset(sigset_t *set, int signum);
	功能 向信号集删除指定信号
	参数 set 指定信号集  signum指定要删除的信号
	返回值 以上成功返回0 错误-1
       int sigismember(const sigset_t *set, int signum);
	功能 测试信号是否是集合中的一员
	参数 set  signum
	返回值 是集合成员 返回1 不是返回0 错误返回-1

	

	sigset_t 类型的操作结束以后 需要将具体的信号集类型的变量设置为进程的信号屏蔽字
	sigprocmask(2) 	

        #include <signal.h>

        int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
	功能 检查或改变信号集
	参数
		how
			SIG_BLOCK   将原来的set和现在指定的set合并
			SIG_UNBLOCK  将set集合中的成员从原来的信号屏蔽子中移除
			SIG_SETMASK  将set设置为阻塞掩码集
		set	要设置的信号掩码集
		oldset	用来保存原来的信号掩码集
	返回值   成功0 错误-1

	举例  在程序中阻塞2号信号(对2号信号屏蔽)
	

	在信号阻塞的时候 多次给进程发送信号 在进程解除对信号的阻塞时 只对阻塞的信号做一次信号处理 造成信号的丢失 这样的信号称为不可靠信号。 这样的信号叫不可靠信号 1～31
	在进程对信号阻塞的时候 多次给进程发送信号 在进程解除对该信号的阻塞的时候 有几个处理几次 这种信号不会造成信号的丢失 这种信号是可靠信号  也叫实时信号 34～64
	

	如何获取未决信号集
	sigpendding(2)
	#include <signal.h>

        int sigpending(sigset_t *set); 没有const 会带回来结果
	功能 返回未决信号的集合  
	参数 set 用来存储进程的未决信号集
	返回值 成功0 错误-1
	
	举例  获取进程的未决信号
		1.对2号进程阻塞
		2.在进程不对2号信号接触阻塞的情况下 获取进程的未决信号
		3.检查2号信号是不是未决信号集的成员

pause(2) 的使用
	
        #include <unistd.h>

        int pause(void);
	功能 等待信号。让出cpu 让当前进程睡觉 直到有一个信号到达。如果默认是终止进程 否则调用信号的捕获函数
		注意 是捕获函数先被执行并返回后 进程才醒来。	
	参数 void
	返回值  错误 -1 在信号处理函数处理之后再返回

	举例  使用alarm 和 pause 实现sleep功能

	#include <stdio.h>
	#include <signal.h>
	#include <unistd.h>

	void doit(int n){};

	unsigned int psleep(unsigned int seconds){
	    alarm(seconds);//三秒后发送一个信号
	    pause();
	    return (alarm(0));//别的信号来了 也会唤醒进程 返回睡眠剩余的秒数
	}


	int main ()
	{

	    //改变信号的默认处理函数
	    signal(SIGALRM,doit);
	    //每睡三秒 唤醒一次
	    while(1){
		psleep(3);
		printf("heihei..\n");
	    }
	    return 0;
	}



	
	计算机中等待有两种方式  轮询(不让出cpu) 中断(让出cpu)

	信号阻塞和信号忽略
		信号阻塞还没有递达给进程 在外面等着
		信号忽略已经递达给进程 不处理

信号从产生到捕获的全过程
	1.在bash下启动一个进程	
	2.按下ctrl+c键 产生硬件中断
	3.cpu切换到内核态处理硬件中断 驱动程序将ctrl+c键解释为2号信号 记录在该进程的PCB中
	4.当进程从内核态切换回用户态的时候，检测该进程的PCB中是否有信号到达的记录 如果没有 直接切换到用户态执行即可  如果有信号到达 调用信号的处理函数 信号处理函数处理完毕以后 调用sigreturn返回内核态 清除信号记录 再返回第四步的开始 循环执行  直到没有信号记录 用户态执行。
	信号和进程是异步的。



可重入函数
	函数只能访问自己栈桢中的数据 这中函数称为可重入函数
	可重入函数不能访问 代码端 数据段 堆里的东西
	可重入函数 不能访问静态变量 全局变量和malloc里面的东西

作业
	jobs
	ctrl+z
	fg %作业号 切换到前台
	bg %作业号 后台执行
	直接方到后台运行 加&

	快捷键发送的信号 只能给前台作业发送信号






关于网络
三次握手
	

		ip的分类
		ip分为私有ip和公有IP
		ip地址的分类
		0~127.0~255.0~255.0~255   A类ip地址   10
		128~191.0~255.0~255.0~255  B类 ip地址  172
		192~223.0~255.0~255.0~255 C类 ip 地址   192

		如何查看路由表？
		sudo route 
		如何查找arp表？
		sudo arp -a

		如何测试两台机器是否互通？
		ping  目标ip地址
		ip地址中有一个比较特殊的ip
		127.0.0.1    本机ip地址（环回地址）
		测试本机的网络通讯设备是否正常。

		下一跳


		二、基于tcp的编程模型
		1、服务器端编程模型
		1）创建一个通讯端点，返回这个设备的文件描述符
		socket(2)
		#include  <sys/types.h>
		#include <sys/socket.h>
		int socket(int domain, int  type,  int  protocol);
		功能：创建一个通讯端点
		参数：
		domain:
		AF_INET:IPV4协议
		AF_INET6:IPV6协议
		type:
		SOCK_STREAM：有序的、可靠的、基于连接的、双向的字节流。TCP
		SOCK_DGRAM：面向数据包的、不可靠的、无须连接的  UDP

		protocol:0
		返回值：
		错误   -1 
		成功  返回一个文件描述符，这个文件描述符就是设备的文件描述符。

		2）将通讯端点的描述符和服务器的ip地址和端口号绑定
		bind(2)
		#include <sys/types.h>          /* See NOTES */
		#include <sys/socket.h>
		int bind(int sockfd, const struct sockaddr *addr,
				socklen_t addrlen);
		功能：把一个名字绑定到一个socket上。
		参数：	
		sockfd：指定了具体的设备。有名字但是没有具体的地址的设备
		addr：指定了具体的地址。
		addrlen：指定addr的大小，字节数。

		返回值：
		成功  0
		错误  -1  errno被设置

		通用地址：
		struct sockaddr{
			sa_family_t sa_family;
			char        sa_data[14];
		};

		ipv4地址：见补充
		ipv6地址

		3）将这个通讯端点的文件描述符设置为被动连接模式，并坚挺客户端连接的到来，如果有连接到来，将其放置到连接队列中。
		未决连接状态
		listen(2)
		#include <sys/types.h>          /* See NOTES */
		#include <sys/socket.h>
		int listen(int sockfd, int backlog);
		功能：监听连接
		参数：
		sockfd：指定了设置为被动连接的设备
		backlog：指定了未决连接队列的最大值。
		返回值：
		成功  0	
		错误  -1   errno被设置

		4）使用accept从未决连接队列中取出一个连接，进行处理。返回服务器和客户端通讯的连接描述符。
		accept(2)
		#include <sys/types.h>          /* See NOTES */
		#include <sys/socket.h>
		int accept(int sockfd, struct sockaddr *addr, \
				socklen_t *addrlen);
		功能：在一个socket上接收连接
		参数：
		sockfd：socket(2)的返回值
		addr：将客户端的地址填充到addr指定的地址空间中。如果为NULL，addrlen也设置为NULL。
		addrlen：指定一个尺寸，值-结果参数。传送进去的时候给一个值，传出的时候，返回一个值。

		返回值：
		错误   -1  errno被设置
		成功  返回一个文件描述符，使用这个文件描述符和客户端通讯。

		while(1){
			5）读取客户端的请求信息  read(2)
			6）处理客户请求信息
			7）将处理结果回送给客户端write(2)
		}
		8)关闭连接描述符，继续回到第四步。
		close(2)

		2、客户端编程模型
		1)创建一个通讯端点，返回该设备的文件描述符sfd
		2)使用这个文件描述符sfd连接服务器（服务器的ip地址和端口号）
		connect(2)

		while(1){
			3)向服务器发送数据
			4）等待服务器的响应消息
			5）处理响应消息
		}
		close(sfd)



		一、connect(2)的应用
		#include <sys/types.h>          /* See NOTES */
		#include <sys/socket.h>
		int connect(int sockfd, const struct sockaddr *addr,
				   socklen_t addrlen);
		功能：在一个socket上发起一个连接
		参数：
		sockfd:指定一个socket文件描述符
		addr:指定地址（服务器的地址和端口），具体是什么地址家族，取决于socket(2)的domain参数。
		addrlen:指定了addr的大小
		返回值：
		成功   0
		错误   -1   errno被设置

		二、TCP网络编程的代码实现
		服务器端代码的实现
		server.c
		客户端代码的实现
		client.c

		解决地址重用的问题   setsockopt(2)

		客户端在输入exit的时候，才断开和服务器的连接
		这时候，服务器为一个客户服务的时候，其他的客户只能等待服务器。这个问题需要解决

		三、并发服务器的实现（多进程   多线程、多路复用）

		父进程负责的任务     
		1）从未决连接队列中取出一个连接，获取和客户端的连接描述符
		2）创建子进程
		3）close(conn_fd);
		4）非阻塞收尸

		子进程负责的任务
		1）close(sfd);
		2)处理客户端的业务
		3）close(conn_fd);
		4)终止子进程

		四、基于UDP的编程模型

		tcp和UDP的区别
		tcp是安全的  可靠的、面向连接的字节流。数据的传输效率低
		UDP是不可靠的，不基于连接的  面向数据包的  传输效率高

		服务器端
		1）创建socket
		2）bind
		while(1){
			3）recvform(2) 从客户端读取数据
			4）加工数据
			5）sendto(2)将数据回送给客户端
		}
		6）关闭socket

		客户端
		1)创建socket
		2）向服务器发送数据   sendto
		3）阻塞接收服务器的响应消息recvfrom
		4）处理消息
		5）关闭socket

		#include <sys/types.h>
		#include <sys/socket.h>
		ssize_t recvfrom(int sockfd, void *buf,size_t len,\
			 int flags, struct sockaddr *src_addr,\
			 socklen_t *addrlen);
		功能：从一个socket上接收一条消息
		参数：
		sockfd：指定socket.
		buf:存储接收到数据的地址
		len：指定了接收区的长度
		flags：0
		src_addr：如果src_addr为NULL，addrlen也指定为NULL。
		src_addr是存储源地址的空间地址
		addrlen：值-结果参数。
		返回值：
		成功  返回接收到的字节数
		错误  -1
		对面关闭   0

		#include <sys/types.h>
		#include <sys/socket.h>
		ssize_t sendto(int sockfd,const void *buf, size_t len,\
			int flags, const struct sockaddr *dest_addr,\ 		socklen_t addrlen);
		功能：在指定的socket上发送一条消息
		参数：
		sockfd：指定发送消息的socket文件描述符
		buf：消息存放的地点
		len：消息的长度
		flags:0
		dest_addr:目标地址
		addrlen:目标地址的长度
		返回值：
		错误  -1    errno被设置
		成功   发送出去的字节数

		编写代码实现  基于udp的服务器端编程  userver.c
		基于udp的客户端编程  uclient.c


		补充：
		一个通用地址
		struct sockaddr{};

		#include <netinet/in.h>

		in_port_t  uint16_t
		in_addr_t  uint32_t
		sa_family_t

		struct in_addr {
			...
			in_addr_t  s_addr;
			...
		};
		IPV4地址
		struct sockaddr_in{
			...
			sa_family_t     sin_family   AF_INET.
			in_port_t       sin_port     Port number.
			struct in_addr  sin_addr     IP address.
			...	
		};
		IP地址无符号的长整型。而我们看到的IP地址是点分十进制的字符串。
		ip地址的转换
		inet_pton(3)
		#include <arpa/inet.h>
		int inet_pton(int af, const char *src, void *dst);
		功能：字符串到长整型的转换
		参数：
		af:
		AF_INET或者 AF_INET6
		src:指定字符串格式的ip地址
		dst:存储转换后的结果。转换后的结果又是什么呢？
		struct in_addr

		返回值：
		1 成功
		0   地址无效
		-1   地址家族错误  errno被设置
		inet_ntop
		#include <arpa/inet.h>
		const char *inet_ntop(int af, const void *src,
				             char *dst, socklen_t size);
		功能：转换ip地址从长整型到字符串格式
		参数：
		af：
		src： struct in_addr
		dst：用来存储字符串的地址。
		size：指定了dst地址空间的长度。
		返回值：
		NULL   错误  errno被设置
		非空的字符串的首地址。

		端口号存储在结构体里的时候，是大端还是小端。
		但是本机的时候是大端还是小端。不确定。
		本机字节序和网络字节序的相互转换
		#include <arpa/inet.h>
		uint32_t htonl(uint32_t hostlong);
		uint16_t htons(uint16_t hostshort);
		uint32_t ntohl(uint32_t netlong);
		uint16_t ntohs(uint16_t netshort);

		h  host
		to
		n   net
		s  short
		l  long



		ipv6地址
		struct sockaddr_in6{
			...
		 	sa_family_t      sin6_family    AF_INET6.
			in_port_t        sin6_port      Port number.
			uint32_t         sin6_flowinfo  IPv6 traffic class and flow information.
			struct in6_addr  sin6_addr      IPv6 address.
			uint32_t         sin6_scope_id  Set of interfaces for a scope.
			...
		};

		一、connect(2)的应用
		#include <sys/types.h>          /* See NOTES */
		#include <sys/socket.h>
		int connect(int sockfd, const struct sockaddr *addr,
				   socklen_t addrlen);
		功能：在一个socket上发起一个连接
		参数：
		sockfd:指定一个socket文件描述符
		addr:指定地址（服务器的地址和端口），具体是什么地址家族，取决于socket(2)的domain参数。
		addrlen:指定了addr的大小
		返回值：
		成功   0
		错误   -1   errno被设置

		二、TCP网络编程的代码实现
		服务器端代码的实现
		server.c
		客户端代码的实现
		client.c

		解决地址重用的问题   setsockopt(2)

		客户端在输入exit的时候，才断开和服务器的连接
		这时候，服务器为一个客户服务的时候，其他的客户只能等待服务器。这个问题需要解决

		三、并发服务器的实现（多进程   多线程、多路复用）

		父进程负责的任务     
		1）从未决连接队列中取出一个连接，获取和客户端的连接描述符
		2）创建子进程
		3）close(conn_fd);
		4）非阻塞收尸

		子进程负责的任务
		1）close(sfd);
		2)处理客户端的业务
		3）close(conn_fd);
		4)终止子进程

		四、基于UDP的编程模型

		tcp和UDP的区别
		tcp是安全的  可靠的、面向连接的字节流。数据的传输效率低
		UDP是不可靠的，不基于连接的  面向数据包的  传输效率高

		服务器端
		1）创建socket
		2）bind
		while(1){
			3）recvform(2) 从客户端读取数据
			4）加工数据
			5）sendto(2)将数据回送给客户端
		}
		6）关闭socket

		客户端
		1)创建socket
		2）向服务器发送数据   sendto
		3）阻塞接收服务器的响应消息recvfrom
		4）处理消息
		5）关闭socket

		#include <sys/types.h>
		#include <sys/socket.h>
		ssize_t recvfrom(int sockfd, void *buf,size_t len,\
			 int flags, struct sockaddr *src_addr,\
			 socklen_t *addrlen);
		功能：从一个socket上接收一条消息
		参数：
		sockfd：指定socket.
		buf:存储接收到数据的地址
		len：指定了接收区的长度
		flags：0
		src_addr：如果src_addr为NULL，addrlen也指定为NULL。
		src_addr是存储源地址的空间地址
		addrlen：值-结果参数。
		返回值：
		成功  返回接收到的字节数
		错误  -1
		对面关闭   0

		#include <sys/types.h>
		#include <sys/socket.h>
		ssize_t sendto(int sockfd,const void *buf, size_t len,\
			int flags, const struct sockaddr *dest_addr,\ 		socklen_t addrlen);
		功能：在指定的socket上发送一条消息
		参数：
		sockfd：指定发送消息的socket文件描述符
		buf：消息存放的地点
		len：消息的长度
		flags:0
		dest_addr:目标地址
		addrlen:目标地址的长度
		返回值：
		错误  -1    errno被设置
		成功   发送出去的字节数

		编写代码实现  基于udp的服务器端编程  userver.c
		基于udp的客户端编程  uclient.c
	
进程件通信  systmp v ipc
	无名管道 亲缘关系进程    
	有名管道 任何进程   
	管道靠的管道文件为桥梁


	

	下面三种是在内核态开辟一块空间 通过管理这个快空间的方式区分
	将消息队列 共享内存 信号量集都称为一个对象
	操作系统的内核需要管理这些对象 每个对象都有自己的id
	

	如何查看这些对象？ ipcs

	如何在用户态访问内核中的这些对象？
	需要在用户态获取这些对象的id
	用户需要使用一个唯一的标识来获取对象的id(键值 身份证)
	
	ftok(3) 获取一个键值
	#include <sys/types.h>
        #include <sys/ipc.h>

        key_t ftok(const char *pathname, int proj_id);
	功能 将pathname和proj_id转换为system V IPC键值
	参数 
		pathname 指定一个存在的 可访问的文件路径
		proj_id  指定一个非0的低八位
	返回值  错误-1  成功返回键值
			
	消息队列
		一个进程往这个内核态空间中写 一个读 作成队列的方式
		msgget(2)
	       #include <sys/types.h>
	       #include <sys/ipc.h>
	       #include <sys/msg.h>

	       int msgget(key_t key, int msgflg);
		功能 获取一个消息队列的id 相当于创建一个消息队列
		参数
			key ftok返回值 
			msgflg
				IPC_CREAT 如果没有跟key值相关的消息队列存在 创建消息队列对象
				IPC_EXEC 同open(2)意义一样
				mode:指定了消息队列的权限 权限的格式同open2
		返回值	错误-1 成功返回消息队列的id


	
	       #include <sys/types.h>
	       #include <sys/ipc.h>
	       #include <sys/msg.h>

	       int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);
		功能 向消息队列插入一条消息
		参数
			msqid 指定了要操作的消息队列的id
			msgp msgbuf结构体变量的地址
			msgsz 指定了消息内容的长度
			msgflg 
					0:阻塞
					IPC_NOWAIT 非阻塞向队列添加消息 如果空间不足 返回EAGIN错误
		返回值 失败-1  成功0
	       ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp,int msgflg);
		功能 从消息队列中取出一条消息
		参数 
			msqid 指定了要操作的消息队列的id
			msgp
			msgsz
			msgtyp 指定了消息队列的类型 从消息队列中取出这个类型的消息
			msgflg  
					IPC_NOWAIT  非阻塞取出消息 
					0：阻塞等待取消息
					MSGNOERROR 
		返回值 失败-1 成功返回实际拷贝的mtxt数组中的字节数
			msgp是自己定义的结构体类型
			   struct msgbuf {
			       long mtype;       /* message type, must be > 0 */
			       char mtext[1];    /* message data */
			   };

		例子：使用消息队列实现两个进程间通信


共享内存

shmget(2)
#include <sys/ipc.h>
#include <sys/shm.h>
int shmget(key_t key, size_t size, int shmflg);
功能：分配一个共享内存段
参数:
key：ftok(3)的返回值
size:指定了共享内存段的尺寸
shmflg:
IPC_CREAT：如果没有共享内存段创建，有就返回共享内存段的id
IPC_EXCL：
mode_flags：指定了共享内存段的访问权限
返回值：
-1  错误   errno被设置
成功  共享内存段的id

举例说明  创建一个共享内存段，获取内存段的id。
代码参见  shmget.c

将共享内存段跟进程的相关地址做关联或解除关联

shmat(2)
shmdt(2)
#include <sys/types.h>
#include <sys/shm.h>
void *shmat(int shmid, const void *shmaddr, int shmflg);
功能：
参数：
shmid：共享内存段的id
shmaddr:指定了关联到进程的虚拟地址空间
NULL   有系统指定合适的地址关联到共享内存段。

shmflg:
SHM_RDONLY：只读
0    读写
返回值：
成功  返回关联到进程的地址
错误  （void *）-1   errno被设置

int shmdt(const void *shmaddr);
功能：解除关联
参数：
shmaddr：指定当前进程的地址，这个地址就是shmat(2)的返回值
返回值：
成功  0
错误  -1  errno被设置

举例说明    使用共享内存实现进程间的通讯  
程序   shma.c实现向共享内存段写入一个字符串“this is a test...\n”

程序   shmb.c实现从共享内存段获取内容，然后将 内容输出到显示器。

3、信号量集

二、线程的基础
程序和进程的区别及其联系
进程是资源分配的基本单位。
线程是执行的基本单位。

线程共享进程的资源。
每个线程还有自己私有的数据。
每个线程还有自己的id。tid

1、在进程中创建一个线程
pthread_create(3)
#include <pthread.h>
int pthread_create(pthread_t *thread,\
	 const pthread_attr_t *attr,
         void *(*start_routine) (void *), void *arg);
功能：创建一个新的线程
参数：
thread:存储新创建的线程的id。
attr:NULL    缺省属性
start_routine:指定线程的执行函数
arg:是线程执行函数的唯一的参数 
返回值：
成功  0 
错误  错误码

Compile and link with -pthread.
void *(*start_routine) (void *);

举例说明    使用  pthread_create(3)创建一个新的线程。
代码参见   pthread_c.c
获取当前进程的pid   getpid(2)
如何获取当前线程的tid呢？
pthread_self(3)

#include <pthread.h>
pthread_t pthread_self(void);
功能：获取当前线程的id
参数：
void
返回值:
永远成功

Compile and link with -pthread.

2、线程的终止、汇合、分离
线程的终止：
1）return和exit(3)的区别
在线程执行函数中最好不要 使用 exit(3)。
return代表的是从函数执行中返回，并不会终止进程。
2)终止当前线程使用   pthread_exit(3)
#include <pthread.h>
void pthread_exit(void *retval);
功能：终止当前线程
参数：
retval:线程的终止状态码被保存在这里。
返回值：
这个函数不返回
3）使用pthread_cancel(3)向一个线程发送取消请求 
#include <pthread.h>
int pthread_cancel(pthread_t thread);
功能：给一个线程发送取消请求
参数：
thread：指定了接收取消请求消息的线程id
返回值：
成功   0
错误   非0的错误码

Compile and link with -pthread.

线程的汇合
pthread_join(3)
#include <pthread.h>
int pthread_join(pthread_t thread, void **retval);
功能：汇合一个终止的线程
参数：
thread：指定要汇合的线程的id。
retval：如果不空，将汇合线程的退出状态码拷贝到*retval地址中
返回值：
成功   0
错误    错误码

举例说明   线程的终止及其汇合
代码参见  pthread_e.c

一、线程的分离
pthread_detach(3)
#include <pthread.h>
int pthread_detach(pthread_t thread);
功能：分离一个线程
参数：
thread：指定要分离的线程的id
返回值：
成功  0
错误   错误码

Compile and link with -pthread.

二、线程同步
举例说明   多个线程访问临界资源异常的问题。
代码参见    count.c
1、mutex锁
1)访问临界资源之前，先加锁。
2）加锁成功，访问临界资源。加锁不成功，等待或者返回错误
3）临界资源访问完毕，解锁。
pthread_mutex_t  类型
#include <pthread.h>
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

int pthread_mutex_init(pthread_mutex_t *mutex,\
		const pthread_mutexattr_t *mutexattr);
功能：使用mutexattr初始化mutex锁
参数：
mutex:指定要初始化的mutex锁
mutexattr：NULL   缺省的属性
返回值：
0

int pthread_mutex_lock(pthread_mutex_t *mutex);
功能：获取mutex锁。如果这个锁被其他线程占有，挂起当前线程，直到另外线程解锁为止。

参数：
mutex：指定要获取的mutex锁
返回值：
成功  0
错误   非0的错误码

int pthread_mutex_trylock(pthread_mutex_t *mutex);
功能：和上边的函数功能一样，但是是非阻塞的
参数：
mutex：指定要获取的锁
返回值：
成功  0
错误   非0的错误码

int pthread_mutex_unlock(pthread_mutex_t *mutex);
功能：解锁
参数：
mutex：指定要解的锁
返回值：
成功  0
错误   非0的错误码

int pthread_mutex_destroy(pthread_mutex_t *mutex);
功能：销毁一个mutex锁，释放hold的资源
参数：
mutex：指定要销毁的mutex锁
返回值：
成功  0
错误   非0的错误码

2、条件变量
什么是条件变量？
有这么一种情况，两个线程，线程A等待某一个条件成立，才继续向下执行。目前条件不成立。线程阻塞在这里。线程B执行，使条件成立。条件成立的时候，告知线程A，线程A继续执行。这个条件就是条件变量。
pthread_cond_t 类型
#include <pthread.h>

//条件变量的静态初始化
pthread_cond_t  cond  =  PTHREAD_COND_INITIALIZER;

int  pthread_cond_init(pthread_cond_t  *cond,
       		pthread_condattr_t *cond_attr);
功能：初始化条件变量
参数：
cond：指定要初始化的条件变量
cond_attr：NULL   默认的属性
返回值：
成功  0
错误  非0

int pthread_cond_signal(pthread_cond_t *cond);
功能：条件变为真，通知启动一个在这个条件上等待的线程
参数：
cond：指定条件变量
返回值：
成功  0
错误  非0
int pthread_cond_broadcast(pthread_cond_t *cond);
功能：
参数：
返回值：

int pthread_cond_wait(pthread_cond_t  *cond,
       			pthread_mutex_t *mutex);
功能：等待条件变为真
参数：
cond:指定条件变量
mutex:指定mutex锁

返回值：
成功  0
错误  非0
1、先解锁mutex
2、等待条件变为真
3、重新获取锁。加锁


int pthread_cond_timedwait(pthread_cond_t *cond,  			pthread_mutex_t  *mutex,\	
		  const struct timespec *abstime);
功能：
参数：
返回值：

int pthread_cond_destroy(pthread_cond_t *cond);
功能：销毁条件变量，释放hold的资源
参数：
cond：指定要销毁的条件变量
返回值：
成功  0
错误  非0
int y=321;  3~5

举例说明条件变量的使用 
生产者生产一个节点，然后将该节点插入到链表的头部。
消费者从链表头部摘取一个节点进行消费。
从而实现生产者和消费者的仿真。
代码参见   pc_cond.c

3、信号量
sem_t  类型
#include <semaphore.h>
int sem_init(sem_t *sem, int pshared, unsigned int value);
功能：初始化一个信号量
参数：
sem：指定了要初始化的信号量的地址
pshared:  
0：多线程
非0 ：多进程

value:指定了用于信号量的值（可用资源数）
返回值：
成功  0
错误  -1  errno被设置

#include <semaphore.h>
int sem_destroy(sem_t *sem);
功能：销毁信号量
参数：
sem:指定要销毁的信号量
返回值：
成功 0
错误  -1  errno被设置

#include <semaphore.h>
int sem_wait(sem_t *sem);
功能：减1操作。使信号量的可用资源数减一
参数：
sem：指定要操作的信号量
返回值：
成功  0
错误 -1  errno被设置

补充：
如果信号量的值>0，立即执行并返回
如果信号量的值==0，阻塞等待信号量的值可减。

int sem_trywait(sem_t *sem);

int sem_timedwait(sem_t *sem, \
	onst struct timespec *abs_timeout);

#include <semaphore.h>
int sem_post(sem_t *sem);
功能：加1操作。
参数：
sem：指定要操作的 信号量
返回值：
成功  0
错误  -1  errno被设置

举例说明  使用信号量的知识实现生产者和消费者的例子
环状队列
代码参见 pc_sem.c

三、system  v IPC
信号量集 
1、ftok(3)
2、使用键值获取一个信号量集的id
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>
int semget(key_t key, int nsems, int semflg);
功能：获取一个信号量集id
参数：
key：ftok(3)的返回值
nsems:信号量集合中信号量的个数
semflg:
IPC_CREAT：
IPC_EXCL：
mode：同open(2)的mode。
返回值：
成功   信号量集的id被返回
错误  -1   errno被设置

对信号量集中的某个信号量的操控
semctl(2)
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>
int semctl(int semid, int semnum, int cmd, ...);
功能：信号量的控制操作
参数：
semid:指定了要操作的信号量集的id
semnum:指定了要控制操作的信号量集中的第几个信号量
cmd:对信号量控制操作的命令
GETVAL：获取信号量的可用资源数
SETVAL：设置信号量的semval值。需要第四个参数，第四个参数的值被设置为该信号量的可用资源数。


...:可变参数，参数的个数和类型取决于cmd。

返回值：
失败    -1   errno被设置
cmd=SETVAL   0
cmd=GETVAL   semval的值

union semun {
      int  val;    /* Value for SETVAL */
      struct semid_ds *buf;/*Buffer for IPC_STAT,IPC_SET*/
      unsigned short  *array; /*Array for GETALL,SETALL*/
      struct seminfo  *__buf;  /* Buffer for IPC_INFO
                       (Linux-specific) */
};

举例说明：
获取一个信号量集，这个信号量集中只有一个信号量。
将这个信号量集中的第一个信号量设置为5.
代码参见  pa.c

pb.c程序中获取信号量集中的第一个信号量的可是用的资源数

对信号量集中某个信号量的操作
semop(2)
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>
int semop(int semid, struct sembuf *sops, unsigned nsops);
功能：信号量操作
参数：
semid：指定了信号量集的id
sops：对信号量的操作
nsops：要操作的信号量的个数。sops指向的数组元素的个数
返回值：
成功   0
错误   -1   errno被设置

struct sembuf{
 	unsigned short sem_num;  /* semaphore number */
        short          sem_op;   /* semaphore operation */
        short          sem_flg;  /* operation flags */
};
sem_num：信号量集中的第几个信号量
sem_op：对信号量的操作
>0   semval+sem_op
=0   等待到0。
<0   
semval>=|sem_op|    semval+sem_op   立即执行
semval<|sem_op|    指定IPC_NOWAIT.  失败
		   没有指定IPC_NOWAIT标记。阻塞等待。



sem_flg：操作标识
IPC_NOWAIT：
SEM_UNDO：
struct sembuf *sops；
struct sembuf arr[3];
sops=arr;



多路IO
epoll  内核对象
int epoll_create 在内核里创建这个对象
int epoll_ctl()
int epoll_wait()	
	





