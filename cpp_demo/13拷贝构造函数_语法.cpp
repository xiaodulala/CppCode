/*
*  拷贝构造函数
×  用一个已经存在的对象构造同类型的副本对象，会调用拷贝构造函数
*  如果一个类没有定义拷贝构造函数 那么编译器会为该类提供一个缺省的拷贝构造函数
*  -->缺省的拷贝构造函数 对成员变量 会按字节复制
*  -->缺省的拷贝构造函数 对成员子对象 会调用成员子对象的拷贝构造函数
*/

/**
 *
 *
 */

#include <iostream>
using namespace std;

class A{
public:
	//这个构造函数 可以叫成无参构造函数 也可以叫成类型转换构造函数
	A(int data=0):m_data(data){}
	//拷贝构造函数
	//语法：必须是对象本身的引用 如果没有引用。编译器会直接报错。原因：如果没有引用，实参到行参相当于也是一个拷贝，在实现拷贝构造函数的时候
	//又调用拷贝构造函数，会造成逻辑上的死循环，所以 如果没有引用，是一个不合法的拷贝构造函数的定义
	//const 的必要性，const可以接受左至和右值  如果没有const不能接受右值。如果要被拷贝的对象的是一个常量，拷贝函数无法实现。
	A(const A& that){
		cout << "A::A(const A&)" << endl;
		m_data = that.m_data;
	}
	int m_data;
};


int main ()
{

	A a1(100);//这个调用的是普通的构造函数
	A a2(a1);//调用了拷贝构造函数
	A a5=a1; //这个其实就是 A a5=A(a1) 当参数为一个的时候 可以省略类型。这三个都等价与33行的生命和初始化。
	cout << a1.m_data << endl;
	cout << a2.m_data << endl;
	const A a3(200);
	A a4(a3);//这里就说明了拷贝函数中 const的必要性
	cout << a4.m_data << endl;
	return 0;
}
