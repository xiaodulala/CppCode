/*
 * 静态成员变量
 * class 类名{
 * 		static 类型 变量名; //声明
 * } 
 * 数据类型 类名::变量名 = 初值 //定义和初始化
 *
 * 使用方法：
 * 	A::静态成员变量 
 * 	对象.静态成员变量
 * 理解：
 * 	静态成员不属于对象 被存放在全局区 不能在构造函数里定义和初始化 需要在类的外部单独定义和初始化。
 * 	他相当与是被限定在类的内部使用的全局变量。静态成员在该类多个实例之间共享。
 * 	静态成员也受到访问限定符的控制。private的静态成员 也不能直接用类名或者对象直接调用，定义和初始化除外 那是语法要求。
 * 	静态成员是属于类的，不属于单独的对象。从内存角度分析 静态成员变量在全局区，而非静态成员在栈区或者堆区，看对象怎么创建。所以可以直接通过
 * 	类名调用静态成员变量，而非静态成员变量属于对象，只有对象创建出来的情况下 非静态成员变量才被分配了内存，这时候才可以调用。
 *
 *
 * 
 * */

#include <iostream>
using namespace std;

class A{
public:
	A(int data):m_data(data){}//静态成员变量不可以在构造函数中初始化
	int m_data;//声明非静态成员变量
	static int s_data;//声明静态成员变量
};
//需要单独定义静态成员变量
int A::s_data = 200;

int main ()
{
	A a1(100);
	cout << "A:size:" << sizeof(A) << endl; //4  
	cout << "a:size:" << sizeof(a1) << endl;//4 说明 静态成员变量 不属于对象

	A a2(100);
	a2.s_data = 300;
	cout << a1.s_data << endl;//300
	cout << a2.s_data << endl;//300  说明多个该类实例化的对象之间共享该静态成员变量

	cout << A::s_data << endl;//300 推荐使用调用静态成员变量的方法。不用对象 用类

	return 0;
}
