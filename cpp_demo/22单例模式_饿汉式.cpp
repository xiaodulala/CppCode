/*
 * 单例模式
 *  一个类只允许存在存在唯一的对象
 *
 *  实现单例模式的思路
 *  1.禁止在类的外部创建对象  --私有化构造函数 包括无参构造函数 拷贝构造函数
 *  2.在类的内部创建对象并使用静态成员变量维护 -- 因为静态变量不属于对象， 使用该类类型申明变量的时候是知道该类大小的。如果用非静态变量来维
 *  	护唯一的对象，申明这个类类型的非静态成员变量的时候，还不知道这个类具体的大小。会造成死递归。
 *  3.提供访问单例模式的方法。--使用静态成员函数   为什么要用静态成员函数，而不用普通成员函数？普通的成员函数虽然也可以访问静态成员变量，
 *  	但是，普通的成员函数需要用对象来调用。由于现在构造函数都是私有的，你在外部根本创建不出来对象，所以没办法调用这个函数。
 *  	用静态成员函数不需要通过对象调用，直接通过类来调用。用他来获取对象。
 *
 *  单例模式的类型
 *  饿汉式：单例对象 无论用不用，程序启动即创建。直到进程结束。随时调用。适合占用内存小，使用频繁的对象。用空间换取时间。
 *  懒汉式：单例对象 用的时候再创建，不用即销毁。和open close类似。适合占用内存大 不经常使用的对象。用时间换取空间。
 *
 * 
 * */
#include <iostream>
using namespace std;
//一个单例模式 饿汉式
class A{
public:
	//3.使用静态成员函数来获取这个唯一对象，一定要返回对象的引用，即对象自身。如果返回不是引用，相当于把返回值拷贝到一个临时变量里，产生一
	//个副本对象，不符合单例模式的要求。
	static A& get_instance(void){
			
			return s_instance;
	}
	void print(){
		cout << m_data << endl;
	}
private:
	//1.首先 私有化构造函数
	A(int data):m_data(data){};
	A(const A& that);//拷贝构造函数，不需要实现。编译器会自动添加。

	//2.声明一个静态成员函数 维护一个唯一的对象。
	// A s_instance  这样是不对的，在创建A类型的时候，就用A类型区声明一个成员变量，这个A类型多大？得看这个成员变量。这个成员变量又是A类型的
	// 造成了死递归。所以必须是静态成员变量来维护这个唯一对象
	static A s_instance;
	int m_data;
};
//定义和初始化静态成员函数 
//相当于是在构造一个对象。构造函数是私有的，这又是类的外部 可以调用吗？--因为这是在定义类的静态成员函数，c++语法规定必须在类的外部定义，
//但是 他其实还是属于这个类的，所以他可以调用类内部的私有成员函数。 
//注意： 这个时候，main函数还没有执行，所以 饿汉式单例模式的特点就是程序启动，即创建。还没启动程序的时候，这个对象已经在内存创建好了。
A A::s_instance(123);


int main ()
{
	//不管调用多少次 获取的都是一个对象
	//一定要申明用A的引用类型接受  否则会调用拷贝构造函数。拷贝构造函数是私有的 调不了。
	A& a = A::get_instance();
	A& a1 = A::get_instance();
	A& a2 = A::get_instance();
	a.print();
	a1.print();
	a2.print();
	return 0;
}




