/*
 * 单例模式
 *  一个类只允许存在存在唯一的对象
 *
 *  实现单例模式的思路
 *  1.禁止在类的外部创建对象  --私有化构造函数 包括无参构造函数 拷贝构造函数
 *  2.在类的内部创建对象并使用静态成员变量维护 -- 因为静态变量不属于对象， 使用该类类型申明变量的时候是知道该类大小的。如果用非静态变量来维
 *  	护唯一的对象，申明这个类类型的非静态成员变量的时候，还不知道这个类具体的大小。会造成死递归。
 *  3.提供访问单例模式的方法。--使用静态成员函数   为什么要用静态成员函数，而不用普通成员函数？普通的成员函数虽然也可以访问静态成员变量，
 *  	但是，普通的成员函数需要用对象来调用。由于现在构造函数都是私有的，你在外部根本创建不出来对象，所以没办法调用这个函数。
 *  	用静态成员函数不需要通过对象调用，直接通过类来调用。用他来获取对象。
 *
 *  单例模式的类型
 *  饿汉式：单例对象 无论用不用，程序启动即创建。直到进程结束。随时调用。适合占用内存小，使用频繁的对象。用空间换取时间。
 *  懒汉式：单例对象 用的时候再创建，不用即销毁。和open close类似。适合占用内存大 不经常使用的对象。用时间换取空间。
 *
 * 
 * */
#include <iostream>
using namespace std;
//创建一个懒汉式单例模式
//
//注意 如果是多线程程序 又可能会同时访问两个静态变量，所以在多线程的时候需要加互斥锁。下面的程序不具备多线程安全性。单线程是可以的。	
class A{
public:
	//获取唯一对象的函数
 	static A& get_instance(void){
		if(s_instance == NULL)//说明还没有创建，new一个出来 指针指向他
			s_instance = new A(123);
		//获取成功，使用对象的人数++
		s_counter++;
		return *s_instance; //不为NULL 说明已经创建，不再创建新的 直接返回已有对象  指针指向的那个对象（解引用）
	}

	void print(void){
		cout << m_data << endl;
	}

	//不用即销毁 要用计数的操作。因为是共用一个对象 所以不能一个不用就直接销毁，别人还在用。所以用计数的方式来作销毁对象的处理
	void release(void){
		//不能直接销毁 由最有一个使用玩这个对象的人销毁 检测使用人数
		if(--s_counter == 0){
			delete s_instance;
			s_instance = NULL;
		}
	}
private:
	//私有化构造函数
	A(int data):m_data(data){};//普通构造函数
	A(const A& that);//拷贝构造
	int m_data;
	//还是声明一个静态成员变量，但是是指针类型的。用的时候再创建出来，用这个指针指向唯一对象。
	//如果不是指针类型，无法达到随用随创建的的要求。为什么是静态的，参考22例子
	static A* s_instance;
	//静态的成员变量 记录又几个人在使用这个对象。
	static int s_counter;
};
//定义和初始化静态成员变量,这就是为什么要用指针类型，先给NULL，可以不直接创建。等创建好对象之后再用指针指向该对象 到达随用随创建。
A* A::s_instance = NULL;
int A::s_counter = 0;



int main ()
{
	//获取对象，只有一个
	A& a = A::get_instance();
	a.print();
	a.release();
	A& a1= A::get_instance();
	a1.print();
	a1.release();
	A& a2= A::get_instance();
	a2.print();
	a2.release();
	return 0;
}


